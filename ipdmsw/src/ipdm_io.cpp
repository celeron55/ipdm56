#include "ipdm_io.h"
#include "ipdm_pca9539.hpp"
#include <avr/pgmspace.h>

namespace ipdm
{

IpdmPca9539 pca9539_0(0x74);
#if IPDM_VERSION >= 101
IpdmPca9539 pca9539_1(0x75);
#endif

void pinMode(int pin, uint8_t mode)
{
	if(pin >= ED0 && pin <= ED15)
		return pca9539_0.pinMode(pin - ED0, mode);
#if IPDM_VERSION >= 101
	if(pin >= ED16 && pin <= ED31)
		return pca9539_1.pinMode(pin - ED16, mode);
#endif
	return ::pinMode(pin, mode);
}

void digitalWrite(int pin, bool state)
{
	if(pin >= ED0 && pin <= ED15)
		return pca9539_0.digitalWrite(pin - ED0, state);
#if IPDM_VERSION >= 101
	if(pin >= ED16 && pin <= ED31)
		return pca9539_1.digitalWrite(pin - ED16, state);
#endif
	return ::digitalWrite(pin, state);
}

bool digitalRead(int pin)
{
	if(pin >= ED0 && pin <= ED15){
		// We don't want to do this automatically, because this way the output state
		// of the pin can't be checked by using this function, when the pin is being
		// used as output.
		//pca9539.pinMode(pin - ED0, INPUT);
		return pca9539_0.digitalRead(pin - ED0);
	}
#if IPDM_VERSION >= 101
	if(pin >= ED16 && pin <= ED31){
		return pca9539_1.digitalRead(pin - ED16);
	}
#endif
	return ::digitalRead(pin);
}

void analogWrite(int pin, uint8_t value)
{
	return ::analogWrite(pin, value);
}

uint16_t analogRead(int pin)
{
	return ::analogRead(pin);
}

static void detect_hw_version()
{
	uint16_t v = analogRead(A5);
	uint16_t detected_version = 0;
	if(v >= 950){
		detected_version = 100; // v1.0: 10k/inf
	} else if(v >= 850){
		detected_version = 101; // v1.1: 10k/100k
	}
	for(;;){
		Serial.print(F("IPDM_VERSION="));
		Serial.print(IPDM_VERSION);
		Serial.print(F(", detected_version="));
		Serial.println(detected_version);
		if(detected_version == IPDM_VERSION)
			break;
		Serial.println(F("-> mismatch"));
		delay(1000);
	}
}

void io_begin()
{
	// Wait a moment to avoid starting on the first reset of a typical double
	// reset generated by our reset circuit
	delay(200);

	detect_hw_version();

	// Initialize Wire (needed by pca9539) after HW version detection, as
	// hardware detection uses the i2c pins as analog pins
	Wire.begin();

#ifdef IPDM_SKIP_IO_EXTENDER_OUTPUT_INITIALIZATION
	// I/O extender output initialization is skipped here.

	// You can enable this behavior by adding into your ipdm_version.h:
	// #define IPDM_SKIP_IO_EXTENDER_OUTPUT_INITIALIZATION

	// This is useful in special cases where you want the outputs to be left in
	// their previous state after rebooting the AVR until your code is reached.

	// What follows are the normal if branches for the different ipdmhw versions
	// in the normal case where we want to initialize the i/o extender outputs.
#elif IPDM_VERSION == 100
	// Set LOUT1...LOUT6, HOUT1...HOUT6 as outputs
	for(int pin=ED4; pin<=ED15; pin++){
		pinMode(pin, OUTPUT);
		digitalWrite(pin, LOW);
	}
#elif IPDM_VERSION == 101
	// Set LOUT1...LOUT6, HOUT5...HOUT10 as outputs
	for(int pin=ED12; pin<=ED23; pin++){
		pinMode(pin, OUTPUT);
		digitalWrite(pin, LOW);
	}
	// Set HOUT1...HOUT4 as outputs
	for(int pin=ED28; pin<=ED31; pin++){
		pinMode(pin, OUTPUT);
		digitalWrite(pin, LOW);
	}
	pinMode(VUSB_PIN, INPUT);
#else // IPDM_VERSION
static_assert(false, "Unsupported IPDM_VERSION");
#endif
}

} // namespace ipdm
